document.addEventListener('DOMContentLoaded', async () => {
    let test_data = null;
    const userAnswers = new Map();
    async function getTestData() {
        const urlParams = new URLSearchParams(window.location.search);
        const testId = urlParams.get('test_id');
        if (!testId) return;

        try {
            const response = await fetch(`http://127.0.0.1:8000/api_v1/tests/${testId}`, {
                method: "GET",
                credentials: "include",
                headers: {
                  "Accept": "application/json"
                }
            });
            const data = await response.json();

            if (!data.title) throw new Error(data.detail || "Тест не найден");

            test_data = data;
            console.log("Данные теста загружены:", test_data);
        } catch (error) {
            console.error("Ошибка загрузки теста:", error);
            alert("Ошибка загрузки теста: " + error.message);
        }
    }

        function renderMatchingQuestion(question, container) {
        const questionElement = document.createElement('div');
        questionElement.className = 'question';
        questionElement.dataset.questionId = question.id;

        const titleElement = document.createElement('div');
        titleElement.className = 'question-title';
        titleElement.textContent = question.title;
        questionElement.appendChild(titleElement);

        const gameContainer = document.createElement('div');
        gameContainer.className = 'matching-game-container';
        gameContainer.innerHTML = `
            <div class="matching-game">
                <div class="column left-column">
                    <div class="card-pairs-container"></div>
                </div>
            </div>`;

        const pairsContainer = gameContainer.querySelector('.card-pairs-container');

        question.options.forEach((pair, index) => {
            const pairNum = index + 1;
            const pairId = `pair-${pairNum}`;
            const leftId = `left-${pairNum}-0`;
            const rightId = `right-${pairNum}-0`;

            pairsContainer.insertAdjacentHTML('beforeend', `
                <div class="card-pair" data-pair-id="${pairId}">
                    <div class="card left-card" data-id="${leftId}" 
                         data-original-id="${leftId}" 
                         contenteditable="false">${pair.text}</div>
                    <div class="card right-card" data-id="${rightId}" 
                         data-original-id="${rightId}" 
                         contenteditable="false">${pair.is_correct}</div>
                </div>`);
        });

        questionElement.appendChild(gameContainer);
        container.appendChild(questionElement);
        initMatchingInteraction(questionElement, question.id);
    }

    function initMatchingInteraction(questionElement, questionId) {
        const gameContainer = questionElement.querySelector('.matching-game');
        let selectedCard = null;
        const matches = {};
        const connectors = [];

        function handleCardClick(e) {
            const card = e.currentTarget;

            if (card === selectedCard) {
                card.classList.remove('selected');
                selectedCard = null;
                return;
            }

            if (card.classList.contains('matched')) {
                const pair = findPairForCard(card.dataset.id);
                if (pair) disconnectPair(pair.leftId, pair.rightId);
            }

            gameContainer.querySelectorAll('.card').forEach(c => {
                c.classList.remove('selected');
            });

            card.classList.add('selected');

            if (!selectedCard) {
                selectedCard = card;
                return;
            }

            if ((selectedCard.classList.contains('left-card') && card.classList.contains('left-card')) ||
                (selectedCard.classList.contains('right-card') && card.classList.contains('right-card'))) {
                selectedCard.classList.remove('selected');
                selectedCard = card;
                return;
            }

            const [leftCard, rightCard] = selectedCard.classList.contains('left-card')
                ? [selectedCard, card]
                : [card, selectedCard];

            connectPair(leftCard, rightCard, questionId);
            selectedCard = null;
        }

        function connectPair(leftCard, rightCard, questionId) {
            const leftId = leftCard.dataset.id;
            const rightId = rightCard.dataset.id;

            if (matches[leftId]) disconnectPair(leftId, matches[leftId]);
            if (Object.values(matches).includes(rightId)) {
                const leftIdToDisconnect = Object.keys(matches).find(key => matches[key] === rightId);
                disconnectPair(leftIdToDisconnect, rightId);
            }

            const leftParts = leftId.split('-');
            const rightParts = rightId.split('-');
            const newLeftId = `left-${leftParts[1]}-${rightParts[1]}`;
            const newRightId = `right-${rightParts[1]}-${leftParts[1]}`;

            leftCard.dataset.id = newLeftId;
            rightCard.dataset.id = newRightId;

            matches[newLeftId] = newRightId;
            userAnswers.set(questionId, {...matches});

            leftCard.classList.add('matched');
            rightCard.classList.add('matched');
            createConnector(leftCard, rightCard);
        }

        function createConnector(leftCard, rightCard) {
            const leftRect = leftCard.getBoundingClientRect();
            const rightRect = rightCard.getBoundingClientRect();
            const gameRect = gameContainer.getBoundingClientRect();

            const leftX = leftRect.right - gameRect.left;
            const leftY = leftRect.top + leftRect.height / 2 - gameRect.top;
            const rightX = rightRect.left - gameRect.left;
            const rightY = rightRect.top + rightRect.height / 2 - gameRect.top;

            const length = Math.sqrt(Math.pow(rightX - leftX, 2) + Math.pow(rightY - leftY, 2));
            const angle = Math.atan2(rightY - leftY, rightX - leftX) * 180 / Math.PI;

            const connector = document.createElement('div');
            connector.className = 'connector';
            connector.style.width = `${length}px`;
            connector.style.left = `${leftX}px`;
            connector.style.top = `${leftY}px`;
            connector.style.transform = `rotate(${angle}deg)`;
            connector.dataset.pair = `${leftCard.dataset.id}-${rightCard.dataset.id}`;

            gameContainer.appendChild(connector);
            connectors.push(connector);
        }

        function disconnectPair(leftId, rightId) {
            const leftCard = questionElement.querySelector(`[data-id="${leftId}"]`);
            const rightCard = questionElement.querySelector(`[data-id="${rightId}"]`);

            if (leftCard) {
                leftCard.classList.remove('matched');
                leftCard.dataset.id = leftCard.dataset.originalId;
            }
            if (rightCard) {
                rightCard.classList.remove('matched');
                rightCard.dataset.id = rightCard.dataset.originalId;
            }

            const connector = gameContainer.querySelector(`.connector[data-pair="${leftId}-${rightId}"]`) ||
                             gameContainer.querySelector(`.connector[data-pair="${rightId}-${leftId}"]`);
            if (connector) connector.remove();
        }

        function findPairForCard(cardId) {
            if (matches[cardId]) {
                return {leftId: cardId, rightId: matches[cardId]};
            }
            for (const [leftId, rightId] of Object.entries(matches)) {
                if (rightId === cardId) return {leftId, rightId};
            }
            return null;
        }

        questionElement.querySelectorAll('.card').forEach(card => {
            card.addEventListener('click', handleCardClick);
        });
    }


    const renderTests = (testData) => {
        const questionContainer = document.querySelector("#form-questions");
        questionContainer.innerHTML = "";

        const durationHours = testData.duration.slice(0, 2);
        const durationMinutes = testData.duration.slice(3, 5);
        document.getElementById('test-hours').value = durationHours;
        document.getElementById('test-minutes').value = durationMinutes;

        testData.questions.forEach(question => {
            const questionElement = document.createElement('div');
            questionElement.className = 'question';
            questionElement.dataset.questionId = question.id;

            const questionTitle = document.createElement('div');
            questionTitle.className = 'question-title';
            questionTitle.contentEditable = true;
            questionTitle.textContent = question.title;

            const selectType = document.createElement('select');
            selectType.className = 'question-type';
            const optionSingle = document.createElement('option');
            optionSingle.value = 'single';
            optionSingle.textContent = 'Один вариант ответа';
            const optionMultiple = document.createElement('option');
            optionMultiple.value = 'multiple';
            optionMultiple.textContent = 'Несколько вариантов ответа';
            const optionText = document.createElement('option');
            optionText.value = 'text';
            optionText.textContent = 'Развернутый ответ';

            if (question.question_type === 'single') {
                optionSingle.selected = true;
            } else if (question.question_type === 'multiple') {
                optionMultiple.selected = true;
            } else if (question.question_type === 'text') {
                optionText.selected = true;
            }

            selectType.appendChild(optionSingle);
            selectType.appendChild(optionMultiple);
            selectType.appendChild(optionText);


            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'options';

            if (question.question_type === 'matching') {
                renderMatchingQuestion(question, questionContainer);
            }

            if (question.question_type === 'text') {
                const textAnswerContainer = document.createElement('div');
                textAnswerContainer.className = 'text-answer-container';
                const textArea = document.createElement('textarea');
                textArea.placeholder = 'Введите развернутый ответ';
                textArea.className = 'text-answer'
                textAnswerContainer.appendChild(textArea);
                optionsContainer.appendChild(textAnswerContainer);
            } else {
                question.options.forEach((option, index) => {
                    const optionElement = document.createElement('div');
                    optionElement.className = 'option';
                    const input = document.createElement('input');
                    input.type = question.question_type === 'single' ? 'radio' : 'checkbox';
                    input.name = `question-${question.id}`;
                    const span = document.createElement('span');
                    span.contentEditable = true;
                    span.textContent = option.text;
                    optionElement.appendChild(input);
                    optionElement.appendChild(span);
                    optionsContainer.appendChild(optionElement);
                });
            }

            selectType.hidden = true;
            questionElement.appendChild(questionTitle);
            questionElement.appendChild(selectType);
            questionElement.appendChild(optionsContainer);

            questionContainer.appendChild(questionElement);
        });
    };

    async function loadTest(testData) {
        try {
            if (testData) {
                document.querySelector("#test-title").textContent = testData.title;
                document.querySelector("#test-description").textContent = testData.description;
                await renderTests(testData);
            }
        } catch (error) {
            console.error("Ошибка загрузки теста:", error);
            alert("Не удалось загрузить тест");
        }
    }

    const saveTest = () => {
        if (!confirm('Вы уверены, что хотите закончить тест?')) return;

        const testTitle = document.querySelector('.form-header h1').textContent.trim();
        const testDescription = document.querySelector('.form-header p').textContent.trim();
        const questions = Array.from(document.querySelectorAll('.question')).map(question => {
            const scores = 10; // получить вес вопроса
            const title = question.querySelector('.question-title').textContent.trim();
            const questionType = question.querySelector('.question-type').value;
            let options = [];
            let answerText = '';

            if (questionType === 'text') {
                answerText = question.querySelector('.text-answer')?.value?.trim() || '';
                options = [{"text": answerText.toLowerCase(), "is_correct": true}]
            } else {
                options = Array.from(question.querySelectorAll('.option')).map(option => ({
                    text: option.querySelector('span').textContent.trim(),
                    is_correct: option.querySelector('input').checked
                }));
            }
            return {title, question_type: questionType, options, answer_text: answerText, scores};
        });

        let testData = {
            title: testTitle,
            description: testDescription,
            questions: questions,
            duration: test_data.duration,
            passing_score: test_data.passing_score
        };

        let testId = null;

        if (test_data && test_data.id) {
            testData['id'] = test_data.id;
            testId = test_data.id;
        }

        const urlParams = new URLSearchParams(window.location.search);
        const firstName = urlParams.get("first_name");
        const lastName = urlParams.get("last_name");
        const email = urlParams.get("email");

        const sendData = {
            "test": testData,
            "tested_user": {
                "email": email,
                "first_name": firstName,
                "last_name": lastName
            }
        }

        let url = 'http://127.0.0.1:8000/api_v1/tested_users/send';
        if (testId !== null) {
            url += `?test_id=${testId}`;
        }
        console.log(url)
        fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken()
            },
            body: JSON.stringify(sendData)
        })
            .then(async (response) => {
                console.log(JSON.stringify(sendData));
                if (response.ok) {
                    alert('Тест успешно сохранен!');
                    window.location.href = 'menu-konst.html';
                    return response.json();
                } else {
                    const errorData = await response.json();
                    alert(errorData.detail || 'Произошла ошибка');
                }
            })
            .catch(error => {
                alert('Ошибка сохранения теста.');
            });
    };

    const getCSRFToken = () => {
        const cookieValue = document.cookie
            .split('; ')
            .find(row => row.startsWith('csrftoken='))
            ?.split('=')[1];
        return cookieValue || '';
    };

    async function init() {
        await getTestData();
        if (test_data) await loadTest(test_data);
        document.querySelector('.hc-button-3').addEventListener('click', saveTest);
    }

    init().catch(error => {
        console.error("Ошибка инициализации:", error);
        alert("Ошибка при загрузке страницы");
    });
});
